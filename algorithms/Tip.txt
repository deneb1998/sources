

// x ^ y 분할정복 //

ll power(ll x, ll y) { 
    ll ret = 1;
    while (y > 0) {
        if (y % 2) {
            ret *= x;
            ret %= P;
        }
        x *= x;
        x %= P;
        y /= 2;
    }
    return ret;
}



// x C y (Combination) 구하기 (범위 큼) //

문제에서 모듈러 소수 P가 주어졌을 때

1) 페르마 소정리 이용
x C y = x! / y!(x-y)!
fac[x] = (fac[x-1] * x) % P (1 ~ x)
inverse[y!] = y! ^ (P-2)
inv[y-1] = inv[y] * y (y-1 ~ 1)
ans = (fac[x] * inv[y]) % P
ans = (ans * inv[x-y]) % P

2) 뤼카의 정리 이용 (추천)
x C y mod P = x,y를 P진법으로 변환 후 각 자리수마다 Combination 후 곱셈
ex. 
152 C 35 mod 10
= 1 C 0 * 5 C 3 * 2 C 5 mod 10
주의점 : 이 경우 x C y 에서 y>x 인 경우가 존재할 수 있으므로 예외처리 필수
주의점2: dp[x][y] = (combi(x-1, y-1) + combi(x-1, y)) % m  ...  <<% m 필수>>


// LIS (증가하는 가장 긴 수열) //

1) lower_bound 이용 
vector<int> v;
v.push(-INF); //중요!
if(v.back()<arr[i]) v.push_back(arr[i]), len++;
else auto it = lower_bound(v.begin(), v.end(), arr[i]); *it = arr[i];
cout << v.size()-1;
주의점 : result != LIS 이다. 오직 LIS length만 알 수 있다.
